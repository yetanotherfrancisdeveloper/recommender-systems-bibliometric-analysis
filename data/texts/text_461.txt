In e-commerce, the watchlist enables users to track items over time and has emerged as a primary feature, playing an important role in usersâ€™ shopping journey. Watchlist items typically have multiple attributes whose values may change over time (e.g., price, quantity). Since many users accumulate dozens of items on their watchlist, and since shopping intents change over time, recommending the top watchlist items in a given context can be valuable. In this work, we study the watchlist functionality in e-commerce and introduce a novel watchlist recommendation task. Our goal is to prioritize which watchlist items the user should pay attention to next by predicting the next items the user will click. We cast this task as a specialized sequential recommendation task and discuss its characteristics. Our proposed recommendation model, Trans2D, is built on top of the Transformer architecture, where we further suggest a novel extended attention mechanism (Attention2D) that allows to learn complex item-item, attribute-attribute and item-attribute patterns from sequential-data with multiple item attributes. Using a large-scale watchlist dataset from eBay, we evaluate our proposed model, where we demonstrate its superiority compared to multiple state-of-the-art baselines, many of which are adapted for this task. â€¢ Applied computing â†’ Electronic commerce. Watchlist, Sequential-Model, Transformers, E-Commerce ACM Reference Format: Uriel Singer, Haggai Roitman, Yotam Eshel, Alexander Nus, Ido Guy, Or Levi, Idan Hasson, Eliyahu Kiperwasser. 2022. Sequential Modeling with Multiple Attributes for Watchlist Recommendation in E-Commerce. In WSDM â€™22: The 15th ACM International Conference on Web Search and Data Mining, February 21â€“25, 2022, Phoenix, AZ, USA. ACM, New York, NY, USA, 10 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn The watchlist, a collection of items to track or follow over time, has become a prominent feature in a variety of online applications spanning multiple domains, including news reading, television watching, and stock trading. One domain in which watchlists have become especially popular is e-commerce, where they allow users to create personalized collections of items they consider to purchase and save them in their user account for future reference. Saving items in the watchlist allows users to track a variety of dynamic characteristics over relatively long period of times. These include the price and related deals, shipping costs, delivery options, etc. A userâ€™s watchlist can be quite dynamic. At any moment, the user may choose to revise her watchlist by adding new items (e.g., after viewing an itemâ€™s page) or removing existing items (e.g., the user has lost her interest in an item). Over time, item attributes may change (e.g., an itemâ€™s price has dropped) or items may become invalid for recommendation (e.g., an item has been sold out). Userâ€™s latest shopping journey may change as well, as she may show interest in other items, categories or domains. All in all, in between two consecutive interactions with the watchlist, the user may change her priority of which next item to pay attention to. Considering the fact that the watchlist of any user may include dozens of items, it may be quite overwhelming for users to keep track of all changes and opportunities related to their watchlist items. Given a limited number of items that can be displayed to the user (e.g., 2-3 items on eBayâ€™s mobile homepage watchlist module) and the dynamic nature of watchlist items, our goal is, therefore, to help users prioritize which watchlist items they should pay attention to next. We cast the watchlist recommendation (hereinafter abbreviated as WLR) task as a specialized sequential recommendation (SR) task. Given the historical interactions of a user with items, the goal of the SR task is to predict the next item the user will interact with [28]. While both tasks are related to each other, we next identify two important characteristics of the WLR task. The î€›rst characteristic of the WLR task is that, at every possible moment in time, only a subset of items,explicitly chosento be tracked by the user prior to recommendation time, should be considered. Moreover, the set of items in a given userâ€™s watchlist may change from one recommendation time to another. Yet, most previous SR studies assume that, the userâ€™s next interaction may be withany possibleitem in the catalog. Therefore, the main focus in such works is to predict the next itemâ€™sidentity. The WLR task, on the other hand, aims to estimate the userâ€™s attention to watchlist items by predicting theclick likelihoodof each item in the userâ€™s watchlist. Noting that watchlist datasets may be highly sparse, as in our case, representing items solely by their identity usually leads to over-î€›t. A better alternative is to represent items by their attributes. Yet, to the best of our knowledge, only few previous SR works can consider attribute-rich inputs both during training and prediction. The second characteristic of the task lies in the important observation that, possible shifts in the userâ€™s preferences towards her watched items may be implied by her recently viewed items (RVIs). For example, a user that tracks a given item in her watchlist, may explore alternative items (possibly not in her watchlist) from the same seller or category, prior to her decision to interact with the tracked item (e.g., the watched item price is more attractive). Trying to handle the unique challenges imposed by the WLR task, we design an extension to the Transformer model [26]. Our proposed Transformer model,Trans2D, employs a novel attention mechanism (termed Attention2D) that allows to learn complex preferential patterns from historical sequences of user-item interactions accompanied with a rich and dynamic set of attributes. The proposed attention mechanism is designed to be highly eî€ective, and requires only a small addition to the modelâ€™s parameters. Using a large-scale user watchlist dataset from eBay, we evaluate the proposed model. We show that, by employing the novel Attention2D mechanism within the Transformer model, our model can achieve superior recommendation performance, compared to a multitude of state-of-the-art SR models, most of which we adapt to this unique task. The watchlist recommendation (WLR) task can be basically viewed as a specialization of the sequential recommendation (SR) task. The majority of previous SR works assume that the input sequence includes only item-IDs [28] and focus on predicting the identity of the next item that the user may interact with [28]. Notable works span from Markov-Chain (MC) [18] and translation-based [7] models that aim to capture high-order relationships between users and items, to works that employ various deep-learning models that capture userâ€™s evolving preferences such as RNNs (e.g., GRU [8,23]), CNNs (e.g., [24,25]), and more recent works that utilize Transformers (e.g., SASRec [10], BERT4Rec [22] and SSE-PT [29]). Similar to [10,22,29], we also utilize the Transformer architecture. Yet, compared to existing works that train models to predict the next item-ID, our model is trained to rank watchlist items according to their click likelihood. The main disadvantage of models that focus on item-ID only inputs is their inability to handle datasets having items with high sparsity and item cold-start issues. Utilizing rich item attributes, therefore, becomes extremely essential for overcoming such limitations, and speciî€›cally in our task. By sharing attribute-representations among items, such an approach can better handle sparse data and item cold-start. Various approaches for obtaining rich attribute-based item representations duringtraining-timehave been studied so far. This includes a variety of attribute representations aggregation methods [2,13,19,20] (e.g., average, sum, element-wise multiplication, etc.), concatenation [3,13,31], parallel processing [9,16], usage of attention-based Transformer layer [30] and graph-based representations [27]. Furthermore, attributes have been utilized for introducing additional mask-based pre-training tasks [32] (e.g., predict an itemâ€™s attribute). Yet, during prediction, leveraging the attributes is not trivial, as the entire catalog should be considered. Indeed, all aforementioned works still utilize only item-IDs for prediction. For example, the S3 [32] model, one of the leading self-supervised SR models, supports only static attributes, which are only considered during its pre-training phase. Hence, extending existing works for handling the WLR task, which requires to consider also item attributes at prediction time, is extremely diî€œcult, and in some cases, is just impossible. As we shall demonstrate in our evaluation (Section 4), applying those previous works [3,13,19,30] that can be extended to handle the WLR task (some with a lot of eî€ort and modiî€›cation), results in inferior recommendation performance compared to our proposed model. Few related works allow to include item attributes as an additional context that can be utilized for representing items both during training and prediction time. Such works either extend basic deepsequential models (RNNs [2,21] and Transformers [5]) with context that encodes attribute-rich features, or combine item-context with sequential data using Factorization Machines [4, 14]. Our proposed model is also capable of processing sequential inputs having multiple item attributes. To this end, our model employs a modiî€›ed Transformer architecture with a novel attention mechanism (Attention2D) that allows to process complete sequences of 2D-arrays of data without the need to pre-process items (e.g., aggregate over attributes) in the embedding layer (as still need to be done in all previous works). This allows our model, with a slight expense of parameters, to capture highly complex and diverse preference signals, which are preserved until the prediction phase. The WLR task can be modeled as a special case of the sequential recommendation (SR) task [28], with the distinction that, at every possible moment, there is only a limited, yet dynamic, valid set of watched items that need to be considered. Using the userâ€™s historical interactions with watchlist items and her recently viewed item pages (RVIs), our goal is, therefore, to predict which items in the current userâ€™s watchlist will be clicked. A userâ€™s click on a watchlist item usually implies that the user has regained her interest in that item. Moreover, we wish to leverage the fact that watched items are dynamic, having attributes whose values may change over time (e.g., price), and therefore, may imply on a change in userâ€™s preferences. Formally, letIbe the set of all recommendable items. For a given userğ‘¢, letWLâŠ† Idenote the set of items in the userâ€™s watchlist priorto the time ofğ‘¡-thclickon any of the watchlist items, termed also hereinafter a â€œwatchlist-snapshotâ€. We further denoteğ‘š= |WL|the number of items in a given snapshot. A user may click on any item inWL, which leads her to the itemâ€™s page; also termed a â€œview itemâ€ (VI) event. VI events may also occurindependently of items in the userâ€™s watchlist; e.g., the user views an item inI following some search result or directed to the itemâ€™s page through some other organic recommendation module, etc. LetVIâŠ† I, with ğ‘›= |VI|, denote a possible sequence of item pages viewed by Figure 1: Watchlist recommendation model (Trans2D) using Transformer with Attention2D layer. The model has three main parts: Embedding layer (bottom-side), Attention2D layer (middle-side) and Prediction layer (upper-right side) The ScaledDotProductAttention2D component is further illustrated in the upper-left side. userğ‘¢between theğ‘¡ âˆ’1-th andğ‘¡-th clicks on her watchlist items, further termed a â€œview-snapshotâ€. We next denoteS(ğ‘¡ )â€“ the userâ€™s history prior to herğ‘¡-th interaction with the watchlist.S(ğ‘¡ )is given by the sequence of the userâ€™s previous clicks on watchlist items and items whose page the user has viewed in between each pair of consecutive clicks, i.e.: S(ğ‘¡ ) = ğ‘¤|{z}, ğ‘£, . . . , ğ‘£, . . . , ğ‘¤|{z}, ğ‘£, . . . , ğ‘£. Here,ğ‘¤denotes a single userâ€™s click on some watchlist item, whileğ‘£denotes an item page viewed by the user. We note that, every watchlist item clicked by the user leads to the itemâ€™s page, hence: ğ‘¤= ğ‘£(âˆ€ğ‘™ : 1 â‰¤ ğ‘™ â‰¤ ğ‘¡ âˆ’ 1). Using the above deî€›nitions, for any given user historyS(ğ‘¡ )and new watchlist snapshotWLto consider, our goal is to predict which items inWLthe user is mostly likely to click next. Therefore, at service time, we wish to recommend to the user the top-ğ‘˜items in WLwith the highest click likelihood. Our WLR model,Trans2D, extends the Transformer [26] architecture for handling sequences with items that include several categorical attributes as in the case of watchlist items. Using such an architecture allows us to capture high-order dependencies among items and their attributes with a minimum loss of semantics and a reasonable model complexity. The modelâ€™s network architecture is depicted in Figure 1. The network includes three main layers, namely, Embedding layer, Attention2D layer and Prediction layer. We next describe the details of each layer. A common modeling choice in most related literature [28], is to represent userâ€™s sequenceS(ğ‘¡ )as the sequence of item-IDs. LetÃ ğ‘ =(1+ğ‘›)denote the total items inS(ğ‘¡ ). These item-IDs are typically embedded into a corresponding sequence ofğ‘‘-dimensional vectorsE = (e, . . . , e);âˆ€ğ‘–:eâˆˆ Rusing an embedding dictionary and serve as input representation to neural-network models. However, such a representation has two main disadvantages. Firstly, it is prone to cold-start problems as items that never appear during training must be discarded or embedded as an â€˜unknownâ€™ item. Secondly, items that only appear once or a few times during training are at high risk of over-î€›tting by the training process memorizing their spurious labels. Such sparsity issues are particularly present in our data (as will be discussed in Section 4.1), prompting us to represent an item as a collection of attributes, rather than an itemID. Such an approach is less prone to sparsity and over-î€›tting, as the model learns to generalize based on item-attributes. Following our choice for item representation, we now assume that each item inS(ğ‘¡ )is represented byğ¶attributes:[ğ‘, . . . , ğ‘]. Therefore, the input to our model is a 2D-array of item attributes S(ğ‘¡ ) = [ğ‘]; whereğ‘– âˆˆ [1, . . . , ğ‘ ], ğ‘— âˆˆ [1, . . . , ğ¶]. Hereinafter, we refer to the î€›rst axis ofS(ğ‘¡ )as the sequence (item) dimension and its second axis as the channel (attribute) dimension. The î€›rst layer of our model is an embedding layer with keys for all possible attribute values in our data. Therefore, by applying this layer on the userâ€™s sequenceS(ğ‘¡ ), we obtain a 2D-array of embedding vectorsE = [ğ‘’]= ğ¸ğ‘šğ‘ğ‘‘ ([ğ‘]). Note that, since each item attribute embedding by itself is ağ‘‘-dimensional vector, E âˆˆ Ris a 3D-array.Eis next fed into a specially modiî€›ed Transformer layer which is our modelâ€™s main processing layer. Most existing SR models (e.g., [8,10,22,24]) take a sequence of vectors as input. However, in our case, we do not have a 1D-sequence of vectors but rather a 2D-array representing a sequence of ordered attribute collections. As Transformers were shown to demonstrate state-of-the-art performance in handling sequential data in general [26] and sequential recommendation data speciî€›cally [5,10,22,29,32], we choose to employ Transformers and extend the Attention Mechanism of the Transformer to handle 2D-input sequences, rather than a 1D-input sequence. Since the vanilla attention model employed by existing Transformer architectures cannot be directly used for 2D-data, diî€erent pooling techniques were devised to reduce the channel dimension and produce a 1D-sequence as an input for the Transformer. For example, in BERT [11], token, position and sentence embeddings are summed before being fed into the Transformer Encoder. Other alternatives to summation were explored such as averaging, concatenation, or a secondary Transformer layer (e.g., [3,30]). Yet, most of these approaches suî€er from a reduction in data representation happening prior to applying the attention workhorse. This makes it harder for the attention mechanism to learn rich attention patterns. An exception is the concatenation approach that sidesteps this problem but produces very long vectors, which in turn, requires Transformer layers to have a large input dimension making them needlessly large. As an alternative, we next proposeAttention2Dâ€“ a dedicated novel attention block that is natively able to handle 2Dinputs in an eî€œcient way. Such an extended attention mechanism will allow us to learn better attention patterns without signiî€›cantly increasing the architecture size. We now describe in detail our modiî€›ed attention block, referred to as Attention2D. For comparison to the vanilla Transformer model, we encourage the reader to refer to [26]. An attention block maps a query (Q) and a set of key (K) - value (V) pairs to an output, where the query, keys, values, and output are all vectors [26]. The Attention2D block in turn receives a 2D-array of vectors, representing a sequence of ordered item attribute collections and computes the attention between all item-attributes while enabling diî€erent semantics per channel to better capture both channel interactions and diî€erences. This way, one attribute of a speciî€›c item can inî€uence another attribute of a diî€erent item regardless of other attributes, making it possible to learn high-order dependencies between diî€erent items and attributes. For instance, in our usecase, the price preferences of a user, captured by the price channel can be computed using attention both to previously clicked item prices and to past viewed items of sellers correlated with pricey or cheap items. The full Attention2D block is illustrated in Figure 1. We now provide a detailed description of its implementation. 3.5.1 Linear2D. The input to our model is a 2D-array of input vectors, generally denoted hereinafterX = [x](and speciî€›cally in our modelâ€™s inputX = E). Our model requires operations acting on such 2D-arrays throughout. To this end, we î€›rst deî€›ne two extensions of standard linear neural-network layers: whereW = [ğ‘Š, . . . ,ğ‘Š];ğ‘ = [ğ‘, . . . , ğ‘]andWâˆˆ R;ğ‘âˆˆ Rare trainable parameters per channel 1â‰¤ ğ‘— â‰¤ ğ¶. These operations deî€›ne a linear layer (with or without bias) with diî€erent trainable parameters per channel and shall allow the model to facilitate interactions between diî€erent channels while preserving the unique semantics of each channel. We start by mapping our input (E) into three 2D-arrays of query Q = [q], keyK = [k]and valueV = [v]vectors corresponding to each input. We do so by applying three Linear2D layers: Q = ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ2ğ·(E) ; K = ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ2ğ·(E) ; V = ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ2ğ·(E) 3.5.2 ScaledDotProductAî€ention2D. We next describe the core part of our proposed attention mechanism, which is used to compute a transformed representation of our 2D-input array. This part is further illustrated on the upper-left side of Figure 1. For brevity of explanation, we consider a single query vector[q]âˆˆ Qand key vector[k]âˆˆ K, while in practice, this operation is performed for every ğ‘–, ğ‘–âˆˆ [1, . . . , ğ‘ ] and ğ‘—, ğ‘—âˆˆ [1, . . . , ğ¶]. First, we compute the following three attention scores (whereğ‘‡ here denotes the matrix transpose operation): A= [q]Â· [k]; A=[q]Â· [k]; where: â€¢ Ais a 4D-array of attention scores between all inputs as the dot-product between every query vector and every key vector. This attention corresponds to the attention scores in a vanilla attention layer between any two tokens, yet with the distinction that in our case we have 2D-inputs. â€¢ Ais a matrix of attention scores between whole items in our input, computed as the marginal attention over all channels. This attention captures the importance of items to each other regardless of a particular channel. â€¢ Ais a matrix of attention scores between channels in our input, computed as the marginal attention over all items. This attention captures the importance of channels to each other regardless of a particular item. The attention scores are further combined using their weighted whereğ›¼, ğ›¼, ğ›¼are learned scalars, denoting the relative importance of each attention variant, respectively. The result of this step is, therefore, a 4D-arrayAof attention scores from any position(ğ‘–, ğ‘—)to every position(ğ‘–, ğ‘—). Similarly to [26], we apply a softmax function overA,with a scaling factorâˆš ofğ‘‘, so that our scores will sum up to 1. We then compute the î€›nal transformed output[o]as a weighted average over all value vectors using the computed attention scores: P = ğ‘ ğ‘œ ğ‘“ ğ‘¡ğ‘šğ‘ğ‘¥Aâˆš; [o]=P[ğ‘£] Finally, we can deî€›ne our Attention2D layer as an attention layer that receives a triplet of(Q, K, V)2D-arrays of query, key and value vectors as its input and outputs a 2D-array transformed vectors: ğ‘†ğ‘ğ‘ğ‘™ğ‘’ğ‘‘ğ·ğ‘œğ‘¡ğ‘ƒğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›2ğ· (Q, K, V) = [o](3) The Attention2D layer allows each item-attribute to attend to all possible item-attributes in the input. To prevent unwanted attendance (such as accessing future information in the sequence), we mask it out by forcing the relevant (future) attention values to âˆ’âˆ before the softmax operation. 3.5.3 Multi-Head Aî€ention2D. Similarly to [26], instead of performing a single attention function, we can applyâ„diî€erent functions (â€œAttention-Headsâ€) over diî€erent sub-spaces of the queries, keys, and values. This allows to diversify the attention patterns that can be learned, helping to boost performance. For instance, one attention head can learn to focus on price-seller patterns, while another on diî€erent price-condition patterns. We facilitate this by applyingâ„diî€erent Linear2D layers, resulting inâ„triplets of (Q, K, V); on each, we apply the aforementioned ScaledDotProductAttention2D layer. We then concatenate allâ„results and project it back to a ğ‘‘-dimensional vector using another Linear2D layer: ğ‘€ğ‘¢ğ‘™ğ‘¡ğ‘–ğ»ğ‘’ğ‘ğ‘‘2ğ· (Q, K, V) = ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ2ğ·(ğ¶ğ‘œğ‘›ğ‘ğ‘ğ‘¡ (â„ğ‘’ğ‘ğ‘‘, ..., â„ğ‘’ğ‘ğ‘‘)) Q= ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·(Q) ; K= ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·(K) ; V= ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·(V) 3.5.4 Position-wise Feed-Forward Networks. We î€›nally allow the Attention2D output to go through additional Linear2D layers in order to be able to cancel out unwanted applied alignments and learn additional complex representations: ğ¹ ğ¹ ğ‘ (X) = ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·(ğ‘…ğ‘’ğ¿ğ‘ˆ (ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·(X))) 3.5.5 Full Layer implementation. A full Attention2D block is combined from a MultiHead2D layer and then a FFN layer, where a residual connection [6] is applied around both, by adding the input to the output and applying a layer normalization [1], as follows: ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›2ğ·(X) = ğ¿ğ‘ğ‘¦ğ‘’ğ‘Ÿ ğ‘ğ‘œğ‘Ÿğ‘š(X+ ğ¹ ğ¹ ğ‘ (X)), After applying the Attention2D block, we end up with a transformed 2D-array of vectorsE= ğ´ğ‘¡ğ‘¡ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘œğ‘›2ğ· (E), having the same shape as the original input. Therefore, Attention2D layers can be further stacked one on the other to achieve deep attention networks. The î€›nal stage in our model is label (click/no-click) prediction. Let ğ‘¤âˆˆ WLbe an item in the userâ€™s watchlist whose click likelihood we wish to predict. To this end, as a î€›rst step, we appendğ‘¤to S(ğ‘¡ ). We then feed the extended sequence to the Transformer and obtainE, the transformed 2D-array representation based on our Attention2D block (see again Eq 5). We predict the click likelihood of itemğ‘¤based on its transformed outputğ‘’âˆˆ R. For that, we î€›rst obtain a single representation of it by applyingğ‘ƒğ‘œğ‘œğ‘™ (ğ‘’)â€“ a pooling layer over the channel dimension inğ‘’. While many pooling options may be considered, we use a simple average pooling. This is similar to the channel dimension reduction discussed in Section 3.4, but instead of applying the pooling before the attention mechanism, we are able to apply the pooling after the Attention2D block. This makes it possible for the Attention2D block to capture better attention patterns between diî€erent items and attributes. Finally, we obtain the itemâ€™s predicted label (denotedË†ğ‘¦) by applying a simple fully connected layer onğ‘ƒğ‘œğ‘œğ‘™ (ğ‘’)to a single neuron representing the itemâ€™s click likelihood, as follows: whereWâˆˆ R;ğ‘âˆˆ Rare trainable parameters, andğœ (Â·)is the Sigmoid activation function. To train the model, we î€›rst obtain a prediction for each item in the target watchlist snapshotWLgiven the userâ€™s historyS(ğ‘¡ ). Let ğ‘¦ âˆˆ {0,1}denote a binary vector having a single entry equal to 1 for the actual item clicked inWL(and 0 for the rest). We then train the model by applying the binary cross-entropy lossÃ over this watchlist snapshot:ğ¿ğ‘œğ‘ ğ‘ =ğ¿ğ‘œğ‘ ğ‘ , where:ğ¿ğ‘œğ‘ ğ‘ = âˆ’[ğ‘¦ğ‘™ğ‘œğ‘”(Ë†ğ‘¦) + (1 âˆ’ğ‘¦)ğ‘™ğ‘œğ‘”(1 âˆ’Ë†ğ‘¦)];Ë†ğ‘¦is predicted according to Eq 6. Atinference, we simply recommend the top-ğ‘˜items inWL having the highest predicted click likelihood according toË†ğ‘¦. We collect a large-scale watchlist dataset that was sampled from the eBay e-commerce platform during the î€›rst two weeks of February 2021. We further sampled only active users with at least 20 interactions with their watchlist during this time period. Due to a sampling limit, for each watchlist snapshot we are allowed to collect a maximum of 15 items, which are pre-ordered chronologically, according to the time they were added by the user to the watchlist. In total, our dataset includes 40,344 users and 5,374,902 items. The data is highly sparse, having 11,667,759 and 1,373,794 item page views and watchlist item clicks, respectively. An average watchlist snapshot includes 10.48 items (stdev: 4.96). Items in our dataset hold multiple and diverse attributes. These include item-ID, user-ID, price (with values binned into 100 equal sized bins using equalized histogram), seller-ID, condition (e.g.,new,used), level1-category (e.g., â€˜Building Toysâ€™), leaf-category (e.g., â€˜Minifiguresâ€™), saletype (e.g.,bid) and site-ID (e.g.,US). Since item-IDs and seller-IDs in our dataset are quite sparse, we further hash these ids per sequence, based on the number of occurrences of each id type in the sequence. For each item in a given userâ€™s history, we keep several additional attributes, namely: position-ID (similar to BERT [11]), associated (watchlist/view) snapshot-ID, interaction type (watchlist-click or item-page-view), hour, day, and weekday of interaction. Additionally, for each item in a given watchlist snapshot, we keep its relative-snapshot-position (RSP) within the watchlist (relative to userâ€™s inclusion time). We note that, we consider all position-based attributes relatively to the sequence end. We split our data over time, having the train-set in the time range of 2â€“11 February 2021, and the test-set in the time range of 12â€“15 February 2021. We further use the most recent 1% of the training time range as our validation-set. 4.2.1 Model implementation and training. We implementTrans2D with pytorch [15]. We use the Adam [12] optimizer, with a starting learning rate of 10,ğ›½=0.9,ğ›½=0.999,â„“weight decay of 10, and dropoutğ‘ =0.3. For a fair comparison, for all baselines (and ourTrans2Dmodel), we set the number of blocksğ¿ =1, number of headsâ„ =4, embedding sizeğ‘‘ =16, and maximum sequence lengthğ‘ =50. To avoid model overî€›tting, we add an exponential decay of the learning rate (i.e., at each epoch, starting from the second, we divide the current learning rate by 10), and train for a total of 5 epochs. We train all models on a single NVIDIA GeForce RTX 3090 GPU with a batch size of 32. 4.2.2 Baselines. The WLR task requires to handle attribute-rich item inputs both during training and prediction. Yet, applying most existing baselines to directly handle the WLR task is not trivial. To recall, many previously suggested SR models support only inputs with item-IDs, and hence, are unsuitable for this task. Moreover, while many other SR models support attributes during training, their prediction is still based on item-IDs only. As the WLR task holds dynamic recall-sets, even those models that do support attributes during prediction, still require some form of adaptation to handle the WLR task. Overall, we suggest (and perform) three diî€erent model adaptations (denoted hereinafterA1,A2andA3, respectively) on such baselines, which we elaborate next. A1: Instead of using item-IDs for item embeddings, as most of our baselines do, we utilize their attributes. We obtain item input embeddings by averaging over each itemâ€™s attribute embeddings. This adaptation always results in a better performance. Hence, we apply it to all baselines that do not naturally handle multi-attributes. A2: Instead of predicting the next item, we train a model to predict clicks over items in the current watchlist snapshot. This adaptation commonly helps to boost performance, as attributes of predicted items are utilized. Therefore, those baselines that do not oî€er a good alternative, are enhanced with this adaptation. We note that, predicting the next item over the current watchlist snapshot only, always results in an inferior performance. A3: TheLatentCross[2] andContextAware[21] baselines utilize context-features during prediction. The context representation is used as a mask to the GRU output. We adapt the context-features to be the average attribute embeddings of the watchlist items. Having described the possible adaptations, we next list the set of baselines that we implement and compare to our proposed model. For each baseline, we further specify which adaptations we apply. â€¢ RSP: Orders watchlist items based solely on the attribute relative-snapshot-position, i.e., relative to each itemâ€™s user-inclusion time, having the newest item ranked î€›rst. â€¢ Price: Orders watchlist items based solely on their price. We report both descending and ascending price orderings. â€¢GRU: Inspired byGRU4Rec[8], we implement a GRU-based model, further applying adaptations A1 and A2. â€¢ GRU: Similar toGRU, with the only change of concatenating the attribute embeddings instead of averaging them. â€¢ Trans: Inspired byBERT4Rec[22],SASRec[10] andSSEPT[29], we implement a Transformer-based model, which is further adapted using adaptations A1 and A2. â€¢ BST[3]: Similar toTrans, with the only change of concatenating the attribute embeddings instead of averaging them. â€¢ Trans: Inspired by [5] and similar toTrans, with the only change of transforming the attribute embeddings by applying a vanilla-Transformer over the channel (attribute) dimension and only then averaging the embeddings. â€¢FDSA: The originalFDSA[30] model oî€ers two components: 1) Transformer over the item-IDs sequence, and 2) vanilla-attention pooling over the attribute embeddings followed by an additional Transformer over the attribute sequence. At the end, the two outputs are concatenated to predict the next item. Inspired byFDSA, we create a similar baseline but adapt its training to our task using adaptationA2. Here we note that, this baseline is the only one among all baselines that explicitly uses the original item-IDs. â€¢ FDSA: Similar toFDSA, but without the item-ID Transformer; noting that using the original item-IDs (compared to their hashed version) may easily cause an over-î€›t over our dataset. â€¢ SeqFM[4]: Extends Factorization Machines [17] (FM) with sequential data; Its inputs are a combination of static and sequence (temporal) features. It learns three diî€erent Transformers based on: 1) attention between the static features themselves 2) attention between the sequence features themselves, and 3) attention between the static and sequence features. It then pools the outputs of each Transformer into a single representation using average. Finally, it concatenates the three representations and predicts a given label. We adapt this baseline to our setting by î€›rst treating the predicted watchlist snapshotWLitemsâ€™ attributes as static features. Additionally, applying adaptationA1, the dynamic features are obtained by averaging the attribute embeddings for all of the items inS(ğ‘¡ ). Using A1, this baseline can be directly used for click prediction. â€¢ CDMF[19]: Implements an extended Matrix-Factorization (MF) method that handles complex data with multiple feedback types and repetitive user-item interactions. To this end, it receives as its input a sequence of all user-item (pair) interactions. The importance of an item to a given user is learned from an attention pooling over all the user-item interactions. The user representation is calculated as the weighted average over all her interacted items. The î€›nal prediction is calculated using the dot-product between the user and item representations. Inspired byCDMF, we implement the same architecture, where we apply adaptations A1 and A2. â€¢LatentCross[2]: Incorporates context features over the output of the GRU layer which limits the prediction to speciî€›c contextfeatures. Therefore, we apply adaptationA3, leveraging the contextfeatures to be the next itemâ€™s features. Using adaptationA1, item features are calculated as the average attribute embeddings. â€¢ ContextAware[21]: Similar toLatentCross, with the exception that the context representation is treated both as a mask to the GRU layer and as additional information using concatenation. 4.2.3 Evaluation metrics. We evaluate the performance of our model and the baselines using a top-k recommendation setting. Accordingly, we use the following common metrics:ğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ ğ‘–ğ‘œğ‘›@ğ‘˜,ğ»ğ‘–ğ‘¡@ğ‘˜, andğ‘ ğ·ğ¶ğº@ğ‘˜, with ranking cutoî€s ofğ‘˜ âˆˆ {1,2,5}. We note that, forğ‘˜ =1, all three metrics have the same value. Hence, for this case, we report onlyğ‘ƒğ‘Ÿğ‘’ğ‘ğ‘–ğ‘ ğ‘–ğ‘œğ‘›@1. We report the average metrics over all recommendation tasks in the test-set. We validate statistical signiî€›cance of the results using a two-tailed paired Studentâ€™s t-test for 95% conî€›dence with a Bonferroni correction. We report the main results of our evaluation in Table 1, where we compare ourTrans2Dmodel to all baselines. As can be observed, Trans2Doutperforms all baselines over all metrics by a large margin. We next notice that, the best baselines afterTrans2Dare GRUandBST(Transformer-based). Common to both baselines Table 1: Main results. Boldfaced results indicate a statistically signiî€›cant diî€erence. Trans2D (our model) 43.51 33.30 21.56 62.19 80.85 35.61 26.12 GRU39.08 31.52 21.24 58.76 79.43 33.23 25.07 FDSA37.84 31.03 21.14 57.80 78.91 32.57 24.76 FDSA36.95 30.37 21.01 56.57 78.35 31.86 24.46 Trans36.77 30.83 21.18 57.37 79.12 32.17 24.62 Trans36.01 30.42 21.10 56.56 78.72 31.68 24.41 GRU35.71 30.41 21.08 56.58 78.65 31.61 24.35 is the fact that they apply a concatenation over the attribute embeddings. While there is no dimensional reduction in the attribute representation, there are still two drawbacks in such baselines. First, the semantic diî€erence between the attributes is not kept; and therefore, the attention cannot be per attribute. Second, the number of parameters in these baselines drastically increases.Trans2D, on the other hand, requires only a slight expense of parameters. Among the next best baselines, are those that employ a Transformer/Attention pooling (i.e.,Trans,FDSA, andFDSA). Next to these are those that use average-pooling (i.e.,TransandGRU). These empirical results demonstrate that, the attribute reduction mechanism is important to avoid losing important attribute information before entering the sequence block. Therefore,Trans2D, which does not require any such reduction in the attribute representations, results in overall best performance. Observing the diî€erence betweenFDSA(as the only baseline that uses the original item-IDs) andFDSA, further shows that using the original item-ID resolves in worse results, as it causes an over-î€›t. This helps verifying the importance of representing items based on their (less sparse) attributes. Furthermore, it is worth noting that, using theoriginalitem-ID as an attribute harms the performance of all other baselines as well. Therefore, we implement all other baselines in this work (including our own model) without the original item-ID attribute (yet, still with its hashed version). We next observe that, the context-aware baselines (i.e.,ContextAwareandLatentCross) perform similar to the average-pooling baselines. Here we note that, these baselines also perform averagepooling over the context-features (also referred to as the â€œnext item featuresâ€). This supports our choice of adding the next possible item to the end of the sequence. Such a choice results in a similar eî€ect to the context-aware approach that adds the itemâ€™s features as context not before the sequence (GRU) block is applied. Moreover, since we have a relatively small recall-set in our setting, it is possible to concatenate the predicted item features to the history sequence and leverage theAttention2Dblock to encode also the recall-set item attributes together with the sequence. Finally, we can observe that, ordering by theRSPattribute results in a reasonable baseline on its own. This in comparison to both Price baselines that only provide a weak signal. This implies that, over our sampled users, the price does not pay a big deal, but rather the short-term interactions. This fact is further supported in our next parameter sensitivity analysis, see Figure 2(e). To better understand how theTrans2Dmodel parameters inî€uence its performance, we check its sensitivity to î€›ve essential parameters: 1)ğ¿, number of attention blocks, 2)â„, number of heads used in the attention mechanism, 3)ğ‘‘, each attribute embedding size, 4)ğ‘, maximum sequence length, and 5) maximum number of days (back) to be considered in the sequence. For each parameter sensitivity check, we set the rest to their default values (i.e.,ğ¿ =1,â„ =4,ğ‘‘ =16, ğ‘ = 50, and days=â€˜Full Historyâ€™ â€“ all days are being considered). We report the sensitivity analysis results (using NDCG@5) in Figure 2. For reference, we also report the sensitivity of the three next best baselines:GRU,BSTandFDSA. In general, we can observe that, in the majority of cases, our model outperforms the baselines. Furthermore, almost in all cases, the other baselines behave similarly to our model. Per parameter, we further make the following speciî€›c observations about our modelâ€™s sensitivity: # Blocks(ğ¿): We notice that, adding a secondAttention2D block on top of the î€›rst helps to learn second-order dependencies. This makes sense, as the two attention matrices of the model,A andA, can capture attention only in the same row or column. The only attention type that can capture dependencies between two cells not in the same row or column isA. Yet, during the attention calculation onA, the cells are not aware of the other values in their row or column. Therefore, a second block is able to capture such second-order dependencies (e.g., price comparison of two diî€erent appearances of the same item or leaf-category). We can further observe that, the third block has less inî€uence on performance. Finally, similar to the results reported in [3], with additional blocks, BSTâ€™s performance actually declines. # Heads(â„): Similar to normal attentions, utilizing more heads enables the attention mechanisms to learn multiple patterns. Here, we explore two main options for head sizes: 1) each head size equals the input size or 2) all head sizes together equal the input size. For our model andFDSAthe î€›rst option is better, while forBST, the second option is better. For the latter, this can be explained by its already over-sized input and data sparsity (see further details next in Embedding Size sensitivity). Overall, we observe that, 4 heads resolves with a good performance, while 5 heads already has a minor impact on our modelâ€™s performance. Embedding Size(ğ‘‘): Interestingly, for our model, an embedding size ofğ‘‘ =32 resolves with the best performance. While the trend forğ‘‘ <32 can be explained by too small representation sizes, the interesting trend is forğ‘‘ >32. This can be explained due the vocabulary size of each attribute. While most attributes include only few or tens of unique values, only user-ID, level1-category, and leafcategory hold 40,344, 1,293, and 25,449 unique values, respectively. Therefore, while a larger representation may help the latter, the rest of the attributes suî€er from over-representation and sparsity. We note that, those baselines that use concatenation (GRUand Figure 2: Parameter Sensitivity results. Y-axis represents ğ‘ ğ·ğ¶ğº@5, while similar trends are observed for all other metrics. BST) can be thought as using a larger representation for each item. This fact supports the performance decline we observe for these baselines: with larger representations, more over-î€›t. Diî€erently from the former two,FDSAactually manages to improve (up to some point) with the increase in embedding size. We attribute this to its usage of the vanilla attention pooling over the attribute embeddings, which in turn, allows it to represent attributes together in an eî€œcient way, even if some are very sparse. Sequence Length(ğ‘) +Days Considered: The result of the RSPbaseline implies that, usersâ€™ watchlist priorities are usually driven by short-term patterns. Such patterns are captured by usersâ€™ recently viewed item pages. We can observe that, for both parameters,ğ‘ =50 orğ‘‘ğ‘ğ‘¦ğ‘  =1 is enough in order to capture most of the important short-term signal. We further see a small improvement in extending the time range or sequence length. This implies that there is still a weak signal that can be captured. Since the sequence model is a Transformer, there is no memory-gate involved (like in GRU); hence, these short-term patterns represent a real user-behaviour. We next perform an ablation study and report the results in Table 2. To this end, every time, we remove a single component from the Trans2Dmodel and measure the impact on its performance. We explore a diverse set of ablations, as follows: âˆ’ğ¿ğ‘–ğ‘›ğ‘’ğ‘ğ‘Ÿ 2ğ·: We switch every Linear2D layer with a Linear1D layer, meaning all channels receive the exact same weights. This ablation allows to better understand the importance of the attributealignment. While this modiî€›ed component downgrades performance, it still outperforms all baselines while keeping the exact same number of parameters as in a regular attention layer (except for the threeğ›¼scalars used in Eq. 2). This conî€›rms that, the improvement of the fullTrans2Dresults are not only driven by the Linear2D layer but also by the attention mechanism itself. âˆ’A,âˆ’A,âˆ’A: We remove each one of the three attention parts from the î€›nal attention calculation in Eq. 2. These ablations allow to better understand the importance of each attention type to the full model implementation. The most important attention part is A, showing that the relationship between userâ€™s items is the most important, following the motivation of the 1D-attention mechanism. Ais followed byAand then byA. As we can further observe,A does not hold signiî€›cant importance. We hypothesis that, whileA is the only attention part that can capture dependencies between two cells not in the same row or column, during the attention calculation onA, the cells are not aware of the other values in their row or column. This can be over-passed by adding an additional Table 2: Ablation results. Starting from the second row, on each, a single component is removed from the model. Model@1 @2 @5 @2 @5 @2 @5 Trans2D (our model) 43.51 33.30 21.56 62.19 80.85 35.61 26.12 -ğ´44.01 33.42 21.56 62.42 80.85 35.82 26.20 -ğ´43.03 33.06 21.53 61.72 80.69 35.32 26.00 -ğ´38.83 31.60 21.36 58.84 79.92 33.24 25.14 Attention2Dlayer, as shown and discussed in Section 4.4 over the # Blocks sensitivity check, see again Figure 2(a). âˆ’ğ‘…ğ‘‰ ğ¼, âˆ’ğ‘¤ğ‘ğ‘¡ğ‘â„ğ‘™ğ‘–ğ‘ ğ‘¡: We remove from the history sequence all items having interaction type=RVI (item-page-view) and interaction type=watchlist (click), respectively. These ablations allow to understand the importance of each interaction type to the WLR task. While both are important, watchlist clicks hold a stronger signal. This actually makes sense: while item page views (RVIs) provide only implicit feedback about userâ€™s potential interests, clicks provide explicit feedback that reî€ect actual user watchlist priorities. âˆ’ğ‘¡ğ‘–ğ‘šğ‘’, âˆ’ğ‘–ğ‘¡ğ‘’ğ‘š, âˆ’ğ‘ğ‘œğ‘ ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›: For each, we remove a group of attributes in order to better understand the importance of the attributes to the WLR task. Forâˆ’ğ‘¡ğ‘–ğ‘šğ‘’, we remove the hour, day, and weekday attributes. Forâˆ’ğ‘–ğ‘¡ğ‘’ğ‘š, we remove the price, condition, level1category, leaf-category, and sale-type attributes. Forâˆ’ğ‘ğ‘œğ‘ ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›, we remove the position-ID, relative-snapshot-position (RSP), snapshotID, hash-item-ID, and hash-seller-ID attributes. Examining the ablations results, shows that the most important attribute-set is the position-set, followed by the item-set, and î€›nally by the time-set. Noticing that the position-set includesRSPexplains their high importance. The time-set is not that important as relative-time is encoded in the position-set. Additionally, the dataset spans over a relatively short period, resolving with less data to learn the importance of a speciî€›c weekday, hour of the day, or day of the month. âˆ’â„ğ‘–ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘¦: To understand the importance of the entire history, we remove all the history sequence, and solely predict overWLâ€“ the last snapshot. We see that, not observing any history, drastically harms the performance of the model. This strengthens the argument that considering userâ€™s history is important for the WLR task. Figure 3: Qualitative Example. For brevity, only 6 out of the 16 possible attributes are presented. The darker the item-attribute cell color is, the more imp ortant it is. The current candidate is surrounded with the black rectangular. We end this section with a qualitative example (see Figure 3) that visualizes the attention values assigned by theTrans2Dmodel to itemsâ€™ attributes in a given user-sequence. The last item in the sequence is the watchlist item for which the model makes a prediction. This item is actually clicked by the user (ğ‘¦ =1) and the modelâ€™s prediction is aligned, assigning it the highest likelihood amongst all watchlist snapshot items (Ë†ğ‘¦ = 0.697). As the learned attention is a 4D-array, representing the attention between any two (item,attribute) pairs (see Section 3.5.2), we î€›rst pick the attention over the last item in the sequence, and then average over the channel dimension. Doing so, resolves us with a 2D-array that can be visualized to better understand the importance of each (item,attribute) pair on the prediction of the item. Observing the channel dimension, we can notice that, diî€erent attributes have diî€erent importance. This strengths the importance of a 2Dattention that is able to learn the attention over a second axis. As we can observe, given the next item to predict, the model emphasizes either previously clicked items related to the current predicted item (e.g., leaf-categories: 8159â€“â€˜Home Security:Safesâ€˜, 4895â€“â€˜Safety:Life Jackets & Preserversâ€˜) or RVIs that belong to the same leaf-category of the current item (8159). Interestingly, the model emphasizes the prices of clicked items in the same leafcategory (8159), which are higher than the predicted itemâ€™s price. In this work, we presented a novel watchlist recommendation (WLR) task. The WLR task is a specialized sequential-recommendation task, which requires to consider a multitude of dynamic item attributes during both training and prediction. To handle this complex task, we proposed Trans2D â€“ an extended Transformer model with a novel self-attention mechanism that is capable of attending on 2D-array data (item-attribute) inputs. Our empirical evaluation has clearly demonstrated the superiority of Trans2D. Trans2D allows to learn (and preserve) complex user preference patterns in a given sequence up to the prediction time. Our work can be extended in two main directions. First, we wish to explore additional feedback sources such as historical user search-queries or purchases. Second, recognizing that Trans2D can be generally reused, we wish to evaluate it over other sequential recommendation tasks and domains.